<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Worker Crash Suite</title>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
    }
    h1 { margin-bottom: 0.5rem; }
    select, button {
      font-size: 1rem;
      padding: 0.5rem 1rem;
      margin: 0.5rem;
      border-radius: 4px;
      border: none;
    }
    button {
      background: #d33;
      color: white;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Worker Crash Suite</h1>
  <p>Pick a method, then hit ‚ÄúCRASH‚Äù</p>
  <select id="method">
    <option value="singleWorker">Single‚ÄêWorker Memory Bomb</option>
    <option value="multiWorker">Multi‚ÄêWorker Memory Flood</option>
    <option value="sharedWorker">SharedArrayBuffer Flood</option>
    <option value="wasmWorker">WASM Memory Grower</option>
    <option value="offscreenWorker">OffscreenCanvas Paint Loop</option>
    <option value="sequence">üî• Full Worker Sequence</option>
  </select>
  <button id="crashBtn">CRASH</button>

  <script>
    // create a worker from source string
    function makeWorker(src) {
      const blob = new Blob([src], { type: 'application/javascript' });
      return URL.createObjectURL(blob);
    }

    // Blob URLs for each worker type
    const urls = {
      singleWorker: makeWorker(`
        onmessage = () => {
          let arr = [];
          while (true) arr.push(new Array(1000000).fill('*'));
        };
      `),

      multiWorker: makeWorker(`
        onmessage = () => {
          let arr = [];
          while (true) arr.push(new Array(1000000).fill('*'));
        };
      `),

      sharedWorker: makeWorker(`
        onmessage = () => {
          while (true) {
            const sb = new SharedArrayBuffer(1024*1024);
            new Uint8Array(sb)[0] = 1;
          }
        };
      `),

      wasmWorker: makeWorker(`
        onmessage = () => {
          const bytes = new Uint8Array([
            0x00,0x61,0x73,0x6d,1,0,0,0,
            1,4,1,96,0,0,
            3,2,1,0,
            5,3,1,0,1,
            7,7,1,3,103,101,116,0,0,
            10,9,1,7,0,65,0,11
          ]);
          WebAssembly.instantiate(bytes).then(obj => {
            const mem = obj.instance.exports.memory;
            while (true) mem.grow(1);
          });
        };
      `),

      offscreenWorker: makeWorker(`
        onmessage = () => {
          const oc = new OffscreenCanvas(10000,10000);
          const ctx = oc.getContext('2d');
          while (true) ctx.fillRect(0,0,10000,10000);
        };
      `)
    };

    const crash = {
      singleWorker() {
        const w = new Worker(urls.singleWorker);
        w.postMessage('go');
      },
      multiWorker() {
        for (let i = 0; i < 10; i++) {
          const w = new Worker(urls.multiWorker);
          w.postMessage('go');
        }
      },
      sharedWorker() {
        const w = new Worker(urls.sharedWorker);
        w.postMessage('go');
      },
      wasmWorker() {
        const w = new Worker(urls.wasmWorker);
        w.postMessage('go');
      },
      offscreenWorker() {
        const w = new Worker(urls.offscreenWorker);
        w.postMessage('go');
      },
      sequence() {
        // launch all at once for maximum speed
        Object.keys(this).forEach(key => {
          if (key !== 'sequence') this[key]();
        });
      }
    };

    document.getElementById('crashBtn').addEventListener('click', () => {
      const method = document.getElementById('method').value;
      // give UI a moment to update before crash
      setTimeout(() => crash[method](), 50);
    });
  </script>
</body>
</html>
